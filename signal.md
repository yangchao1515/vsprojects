# 信号

信号本质：软中断信号（signal，又简称为信号）通知进程发生某件事情（会打断当前的阻塞操作，区处理事情）。信号是进程间通信机制中唯一的异步通信机制，一个进程不必通过任何操作来等待信号的到达，。信号机制除了基本通知功能外，还可以传递附加信息。

##### 信号的分类：

​	可靠信号：1—31

​	非可靠信号：34—64



信号的生命周期：信号产生 —》信号在进程中注册 —》信号在进程中注销 —》信号处理



### 1.信号的产生：

​	硬件产生：例如ctrl+c	ctrl+l	ctrl+z

​	软件产生：通过kill命令产生

⽤用kill -l命令可以察看系统定义的信号列表

产生方式：

	1.⽤用户在终端按下某些键时,终端驱动程序会发送信号给前台进程。

​	2.硬件异常产⽣生信号,比如内存访问错误。

​	3.⼀一个进程调⽤用kill(2)函数可以发送信号给另⼀个进程。

	4。软件条件产生。



### 2.信号注册：

信号在进程中注册指的就是信号值加入到进程的未决信号集sigset_t signal（每个信号占用一位）中，并且信号所携带的信息被保留到未决信号信息链的某个sigqueue结构中。只要信号在进程的未决信号集中，表明进程已经知道这些信号的存在，但还没来得及处理，或者该信号被进程阻塞。

​	同一个实时信号可以在同一个进程的未决信号信息链中占有多个sigqueue结构（进程每收到一个实时信号，都会为它分配一个结构来登记该信号信息，

​	同一个非实时信号在进程的未决信号信息链中，至多占有一个sigqueue结构。

​	总结：非可靠信号的注册：判断是否有相同的未决信号（判断pending信号集合位图是否为1，），如果有，什么事情也不做，否则修改进程Pcb中信号的pending位图，pending位图置1，添加一个信号的sigqueue结构体节点

​		    可靠信号的注册：判断是否有相同的未决信号，有就直接添加节点，没有就修改位图，添加节点

​            



### 3.信号注销：

在其从内核空间返回到用户空间时会检测是否有信号等待处理。如果存在未决信号等待处理且该信号没有被进程阻塞，则在运行相应的信号处理函数前，进程会把信号在未决信号集合中占有的结构删除



==注意：内核处理一个进程收到的信号的时机是在一个进程从内核态返回用户态时。所以，当一个进程在内核态下运行时，软中断信号并不立即起作用，要等到将返回用户态时才处理。进程只有处理完信号才会返回用户态，进程在用户态下不会有未处理完的信号。==



信号的三种处理方式

​	进程接受到信号后退出

​	进程忽略信号，就像没发生一样

​	进程收到信号后执行用户设定用系统调用signal的函数



### 4.信号的处理安装：

进程要处理该信号就得在进程中安装该信号（进程要处理哪个信号，将执行什么操作）

​	Linux下信号的安装有两个函数signal()、sigaction()，其中signal()不支持信息的传递，主要用与非可靠信号的安装，而sigaction()支持信号传递信息，主要用与 sigqueue() 系统调用配合使用，当然，sigaction()同样支持非实时信号的安装。sigaction()优于signal()主要体现在支持信号带有参数。





信号的自定义处理方式：

​		signal(信号编号，处理方式)

​						默认处理方式		SIG_DFL

​						忽略处理方式		SIG_IGN

​						自定义处理方式 	typedef void(*sighandler_t)(int);))  sighandler_t是回调函数

​							signal(itn signum, sighandler_t handler)



![1556456659546](C:\Users\thinkpad\AppData\Local\Temp\1556456659546.png)



信号的阻塞：在信号的生命周期中会出现信号的阻塞等情况（阻止信号被处理）（不处理不代表不注册）在进程中不标记



![1556446670868](C:\Users\thinkpad\AppData\Local\Temp\1556446670868.png)

sigprocmask:对信号阻塞集合进行操作的接口

			SIG_BLOCK		block = block | set	添加阻塞

			SIG_UNBLOCL		block = block & ~ set	解除阻塞

​			SIG_SETMASK		block = =mask	设置



在所有信号中有两个信号不能被阻塞。